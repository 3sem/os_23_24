#### Некоторые из возможных вопросов для зачёта / промежуточного оценивания / самоконтроля:
1) Прочитаем обычный ELF-файл утилитой readlelf -l. Заметим, что на разные секции стоят разные настройки прав доступа: одни секции можно читать и писать, другие - читать и исполнять, третьи - просто читать. Объясните, почему, и поясните по выводу утилиты, какие секции файла соответствуют каким секциям виртуальной памяти процесса.
2) Дают ли вызовы read/write гарантию целостного вычитывания/записи всех принятых/готовых к приёму данных? Почему на практике работы с каналами (с любыми потоковыми средствами IPC) их предпочитают оборачивать в цикл?
3) Приведите вариант реализации подудуплексного и дуплексного потокового IPC для ОС Linux на ЯП C, пользуясь для этого IPC "канал" (pipe, FIFO).
4) Почему при выводе значения указателя на один и тот же глобальный объект (массив, переменную, и пр.) при двух разных запусках одной той же программы мы наблюдаем разные значения? Какие значения мы будем наблюдать, если установим /proc/sys/kernel/randomize_va_space в 0? Зачем нужна эта переменная?
5) Почему при долгом рассчёте вычислительных задач на потоках хорошей практикой является "привязывание" (affinity setting) потоков к одним и тем же ядрам CPU? 
6) Для каких сигналов гарантирован хотя бы порядок доставки для сигналов одного типа? За счёт чего?
7) Почему при разработке фоновых служб ("демонов"), после создания процесса под службу, хорошей практикой является установка корневой директории как текущей?
8) Объясните, как пространства имён процессов (PID namespaces) и вызов prctl(PR_SET_CHILD_SUBREAPER, ...), лежащие в основе технологии контейнерной виртуализации на пространствах имён в Linux, обеспечивают изоляцию поддеревьев в дереве процессов.
9) Чем сценарий обычного монтирования вызовом mount отличается от bind mount? Приведите пример.
10) Перечислите основные преимущества и недостатки вызовов select, poll, epoll. В чём заключается улучшение ppoll/pselect в сравнении с poll/select?
11)

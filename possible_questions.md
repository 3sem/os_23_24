#### Задачи:
1) [Эмулятор терминала](https://github.com/3sem/os_23_24/blob/main/task_1/task_1.md)
2) [Дуплексный PIPE для Linux](https://github.com/3sem/os_23_24/blob/main/task_2/task_2.md)
3) [Эксперименты с IPC](https://github.com/3sem/os_23_24/blob/main/task_3/task.txt)
4) [Распределённый рассчёт интеграла методом Монте-Карло](https://github.com/3sem/os_23_24/blob/main/task_4/task.txt)
5) [Передача файла сигналами](https://github.com/3sem/os_23_24/blob/main/task_5/task.txt)
6) [Фоновая служба](https://github.com/3sem/os_23_24/blob/main/task_6/task.txt)
7) [FIFO-клиент-сервер](https://github.com/3sem/os_23_24/blob/main/task_7/task.txt)
8) [Распределённый рассчёт интеграла методом Монте-Карло с распараллеливанием по сети](https://github.com/3sem/os_23_24/blob/main/task_8/task.md)


#### Некоторые из возможных вопросов для зачёта / сдачи заданий / промежуточного оценивания / самоконтроля:
1) Прочитаем ELF-файл утилитой readlelf -l. Заметим, что на разные секции стоят разные настройки прав доступа: одни секции можно читать и писать, другие - читать и исполнять, третьи - просто читать. Объясните, почему, и поясните по выводу утилиты, какие секции файла соответствуют каким секциям виртуальной памяти процесса.
2) В описании вызовов типа exec* в MAN указан код возврата только для случая, когда вызов завершился с ошибкой. Почему?
3) Дают ли вызовы read/write гарантию целостного вычитывания/записи всех принятых/готовых к приёму данных? Почему на практике работы с каналами (с любыми потоковыми средствами IPC) их предпочитают оборачивать в цикл?
4) Приведите вариант реализации подудуплексного и дуплексного потокового IPC для ОС Linux на ЯП C, пользуясь для этого IPC "канал" (pipe, FIFO).
5) Почему для передачи данных между процессами разделяемая память и канальные примитивы IPC (pipe, FIFO) эффективнее, чем очереди сообщений?
6) Почему при выводе значения указателя на один и тот же глобальный объект (массив, переменную, и пр.) при двух разных запусках одной той же программы, скомпилированной с флагом -fno-PIE, мы наблюдаем разные значения? Какие значения мы будем наблюдать, если установим /proc/sys/kernel/randomize_va_space в 0? Зачем нужна эта переменная?
7) Как посредством вызова clone создать поток, аналогичный потоку, создаваемому посредством pthread_create по умолчанию?
8) Почему при долгом рассчёте вычислительных задач на потоках хорошей практикой является "привязывание" (affinity setting) потоков к одним и тем же ядрам CPU? 
9) Для каких сигналов гарантирован хотя бы порядок доставки для сигналов одного типа? За счёт чего?
10) Предложите и реализуйте способ передачи файла между двумя процессами путём отображения содержимого на разделяемую память.
11) Почему при разработке фоновых служб ("демонов"), после создания процесса под службу, хорошей практикой является установка корневой директории как текущей?
12) Объясните, как пространства имён процессов (PID namespaces) и вызов prctl(PR_SET_CHILD_SUBREAPER, ...), лежащие в основе технологии контейнерной виртуализации на пространствах имён в Linux, обеспечивают изоляцию поддеревьев в дереве процессов.
13) Чем сценарий обычного монтирования вызовом mount отличается от bind mount? Приведите пример.
14) Перечислите основные преимущества и недостатки вызовов select, poll, epoll. В чём заключается улучшение ppoll/pselect в сравнении с poll/select?
15) Назовите основные преимущества обработки установленных TCP-соединений в отдельных потоках.


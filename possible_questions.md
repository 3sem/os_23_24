#### Некоторые из возможных вопросов для зачёта / промежуточного оценивания / самоконтроля:
- Прочитаем обычный ELF-файл утилитой readlelf -l. Заметим, что на разные секции файла стоят разные настройки прав доступа: одни секции можно читать и писать, другие -- читать и исполнять, либо просто читать. Объясните, почему, и поясните по выводу утилиты, какие секции файла соответствуют каким секциям виртуальной памяти процесса.
- Дают ли вызовы read/write гарантию целостного вычитывания/записи всех принятых/готовых к приёму данных? Почему на практике работы с каналами (пайпами либо любыми потоковыми средствами IPC) их предпочитают оборачивать в цикл?
- Приведите вариант реализации подудуплексного и дуплексного потокового IPC для ОС Linux на ЯП C, пользуясь для этого IPC "канал" (pipe, FIFO).
- Почему при выводе значения указателя на один и тот же глобальный объект (массив, переменную, и пр.) при двух разных запусках одной той же программы мы наблюдаем разные значения. Какие значения мы будем наблюдать, если установим /proc/sys/kernel/randomize_va_space в 0? Зачем нужна эта переменная?
-  
- Для каких сигналов гарантирован хотя бы порядок доставки для сигналов одного типа? За счёт чего?
- Почему при разработке фоновых служб ("демонов"), после создания процесса под службу, хорошей практикой является установка корневой директории как текущей?
- Объясните, как пространства имён процессов (PID namespaces) и вызов prctl(PR_SET_CHILD_SUBREAPER, ...), лежащие в основе технологии контейнерной виртуализации на пространствах имён в Linux, обеспечивают изоляцию поддеревьев в дереве процессов.
- 
- Перечислите основные преимущества и недостатки вызовов select, poll, epoll. В чём заключается улучшение ppoll/pselect в сравнении с poll/select?


